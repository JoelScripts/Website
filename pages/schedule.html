<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üìÖ Schedule ‚Äî Flying With Joel</title>
  <meta name="description" content="7 Day stream schedule for Flying With Joel." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://flyingwithjoel.co.uk/pages/schedule.html" />
  <meta property="og:title" content="Schedule - Flying With Joel" />
  <meta property="og:description" content="View the 7-day stream schedule for Flying With Joel." />
  <meta property="og:image" content="https://flyingwithjoel.co.uk/assets/hero-plane.jpg" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:url" content="https://flyingwithjoel.co.uk/pages/schedule.html" />
  <meta name="twitter:title" content="Schedule - Flying With Joel" />
  <meta name="twitter:description" content="View the 7-day stream schedule for Flying With Joel." />
  <meta name="twitter:image" content="https://flyingwithjoel.co.uk/assets/hero-plane.jpg" />
  <link rel="stylesheet" href="../assets/css/styles.css" />
  <script src="../assets/js/site-mode.js?v=20260216"></script>
  <style>
    .schedule-nav { display: flex; align-items: center; justify-content: space-between; gap: 1rem; }
    .schedule-nav-left { display: flex; align-items: center; gap: 0.8rem; }
    .home-btn {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.45rem 0.75rem;
      border-radius: 0.55rem;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: #e0e0e0;
      text-decoration: none;
      font-weight: 800;
      white-space: nowrap;
    }
    .home-btn:hover { border-color: rgba(0, 102, 255, 0.55); }

    .nav-mobile { display: none; }
    .nav-mobile select {
      width: 100%;
      min-width: 170px;
      padding: 0.55rem 0.75rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.25);
      color: #fff;
      font-weight: 700;
    }

    @media (max-width: 720px) {
      .nav-links { display: none !important; }
      .nav-mobile { display: block; }
    }
  </style>
</head>
<body>
  <nav class="navbar navbar--v2">
    <div class="nav-container">
      <div class="schedule-nav">
        <div class="schedule-nav-left">
          <div class="logo">flywithjoel</div>
          <a class="home-btn" href="../index.html" aria-label="Go to Home">
            <span class="nav-icon" aria-hidden="true">üè†</span>Home
          </a>
        </div>

        <ul class="nav-links" style="display:flex; gap: 1rem;">
          <li><a href="../index.html"><span class="nav-icon" aria-hidden="true">üè†</span>Home</a></li>
          <li><a href="suggestions.html"><span class="nav-icon" aria-hidden="true">üí°</span>Suggestions</a></li>
          <li><a href="privacy.html"><span class="nav-icon" aria-hidden="true">üîê</span>Privacy</a></li>
          <li><a href="terms.html"><span class="nav-icon" aria-hidden="true">üìú</span>Terms</a></li>
        </ul>

        <div class="nav-mobile" aria-label="Mobile navigation">
          <select id="mobile-nav" aria-label="Navigate">
            <option value="" selected>Navigate‚Ä¶</option>
            <option value="../index.html">Home</option>
            <option value="suggestions.html">Suggestions</option>
            <option value="privacy.html">Privacy</option>
            <option value="terms.html">Terms</option>
            <option value="security.html">Security</option>
          </select>
        </div>
      </div>
    </div>
  </nav>

  <section class="upcoming-section" style="padding-top: 2rem;">
    <div class="schedule-header">
      <div class="schedule-icon">üìÖ</div>
      <div>
        <h2>7 Day Schedule</h2>
        <p class="schedule-subtitle">Live badge auto-applies when the stream is live (Zulu time).</p>
      </div>
    </div>

    <div class="weekly-schedule is-hydrating" id="weekly-schedule" style="margin-bottom: 2rem;">
      <!-- Fallback schedule (used if the API can't be reached). The Worker-backed schedule will replace this. -->
      <div class="day-card" data-date="1-19">
        <div class="day-name">MON</div>
        <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">Jan 19</div>
        <div class="game-logo">-</div>
        <div class="stream-time">No Stream Planned</div>
        <div class="stream-title">-</div>
      </div>

      <div class="day-card has-stream completed" data-date="1-20">
        <div class="day-name">TUE</div>
        <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">Jan 20</div>
        <div class="game-logo">‚úàÔ∏è</div>
        <div class="stream-time" data-zulu-time="18:00 Zulu">18:00 Zulu</div>
        <div class="stream-title">Microsoft Flight Simulator</div>
        <a href="https://www.twitch.tv/Flyingwithjoel/videos" target="_blank" rel="noopener noreferrer" style="font-size: 0.8rem; color: #66BB6A; margin-top: 0.5rem; font-weight: 600; text-decoration: none; display: block; cursor: pointer; transition: color 0.2s;">‚úì Completed - Watch VOD</a>
      </div>

      <div class="day-card has-stream completed" data-date="1-21">
        <div class="day-name">WED</div>
        <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">Jan 21</div>
        <div class="game-logo">‚úàÔ∏è</div>
        <div class="stream-time" data-zulu-time="18:00 Zulu">18:00 Zulu</div>
        <div class="stream-title">Microsoft Flight Simulator</div>
        <a href="https://www.twitch.tv/Flyingwithjoel/videos" target="_blank" rel="noopener noreferrer" style="font-size: 0.8rem; color: #66BB6A; margin-top: 0.5rem; font-weight: 600; text-decoration: none; display: block; cursor: pointer; transition: color 0.2s;">‚úì Completed - Watch VOD</a>
      </div>

      <div class="day-card has-stream cancelled" data-date="1-22">
        <div class="day-name">THU</div>
        <div class="day-date" style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">Jan 22</div>
        <div class="game-logo">‚úàÔ∏è</div>
        <div class="stream-time" data-zulu-time="15:30 Zulu">15:30 Zulu</div>
        <div class="stream-title">Microsoft Flight Simulator</div>
        <div style="font-size: 0.8rem; color: #ff6666; margin-top: 0.5rem; font-weight: 600;">‚úñÔ∏è Cancelled</div>
      </div>

      <div class="day-card has-stream completed" data-date="1-23">
        <div class="day-name">FRI</div>
        <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">Jan 23</div>
        <div class="game-logo">‚úàÔ∏è</div>
        <div class="stream-time" data-zulu-time="18:00 Zulu">18:00 Zulu</div>
        <div class="stream-title">Microsoft Flight Simulator</div>
        <a href="https://www.twitch.tv/videos/2677982122" target="_blank" rel="noopener noreferrer" style="font-size: 0.8rem; color: #66BB6A; margin-top: 0.5rem; font-weight: 600; text-decoration: none; display: block; cursor: pointer; transition: color 0.2s;">‚úì Completed - Watch VOD</a>
      </div>

      <div class="day-card has-stream" data-date="1-24">
        <div class="day-name">SAT</div>
        <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">Jan 24</div>
        <div class="game-logo">‚úàÔ∏è</div>
        <div class="stream-time" data-zulu-time="11:00 AM Zulu">11:00 AM Zulu</div>
        <div class="stream-title">Microsoft Flight Simulator</div>
      </div>

      <div class="day-card has-stream" data-date="1-25">
        <div class="day-name">SUN</div>
        <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">Jan 25</div>
        <div class="game-logo">‚úàÔ∏è</div>
        <div class="stream-time" data-zulu-time="11:00 AM Zulu">11:00 AM Zulu</div>
        <div class="stream-title">Microsoft Flight Simulator</div>
      </div>
    </div>

    <p id="schedule-note" class="schedule-subtitle" style="margin-top: 0.5rem; color: var(--text-muted);"></p>
  </section>

  <footer class="footer" style="margin-top: 3rem;">
    <div class="footer-content">
      <p>&copy; 2026 Flying With Joel. All rights reserved.</p>
      <div class="footer-links">
        <a href="privacy.html">Privacy Policy</a>
        <a href="terms.html">Terms of Service</a>
        <a href="cookies.html">Cookie Policy</a>
        <a href="#" id="cookie-settings-link">Cookie Settings</a>
        <a href="security.html">Security & Hosting</a>
      </div>
    </div>
  </footer>

  <!-- Cookie Consent Banner -->
  <div id="cookie-consent-banner" class="cookie-consent-banner">
    <div class="cookie-consent-content">
      <p>We use local storage (localStorage) to remember your choices (such as your consent preference for optional third-party embeds/resources). <a href="privacy.html">Learn more about our privacy practices</a>.</p>
    </div>
    <div class="cookie-consent-buttons">
      <button id="cookie-accept-btn" class="cookie-consent-btn accept">Accept</button>
      <button id="cookie-reject-btn" class="cookie-consent-btn decline">Decline</button>
    </div>
  </div>

  <script src="../assets/js/main.js"></script>

  <script>
    const SCHEDULE_API_CANDIDATES = [
      '/api/schedule',
      'https://api.flyingwithjoel.co.uk/api/schedule.php',
    ];

    // Used to pick the matching live-status endpoint.
    // Populated at runtime after the schedule JSON loads.
    let lastScheduleApiUrl = null;

    const SCHEDULE_API_LOCALSTORAGE_KEY = 'fwj_schedule_api';

    const ALLOWED_API_ORIGINS = new Set([
      window.location.origin,
      'https://flyingwithjoel.co.uk',
      'https://www.flyingwithjoel.co.uk',
      'https://api.flyingwithjoel.co.uk',
    ]);

    function sanitizeApiUrl(raw) {
      const s = (raw || '').trim();
      if (!s) return null;

      if (s.startsWith('/')) {
        if (!s.startsWith('/api/')) return null;
        return s;
      }

      try {
        const u = new URL(s);
        if (u.protocol !== 'https:') return null;
        if (!ALLOWED_API_ORIGINS.has(u.origin)) return null;
        if (!u.pathname.startsWith('/api/')) return null;
        u.hash = '';
        return u.toString();
      } catch {
        return null;
      }
    }

    function getScheduleApiOverride() {
      try {
        const params = new URLSearchParams(window.location.search);
        const qp = sanitizeApiUrl(params.get('scheduleApi'));
        if (qp) {
          localStorage.setItem(SCHEDULE_API_LOCALSTORAGE_KEY, qp);
          return qp;
        }
      } catch {
        // ignore
      }

      try {
        const fromLs = sanitizeApiUrl(localStorage.getItem(SCHEDULE_API_LOCALSTORAGE_KEY));
        if (fromLs) return fromLs;
      } catch {
        // ignore
      }

      const meta = document.querySelector('meta[name="schedule-api"]');
      const metaVal = sanitizeApiUrl(meta ? meta.getAttribute('content') : '');
      return metaVal;
    }

    function getScheduleApiCandidates() {
      const override = getScheduleApiOverride();
      const all = [override, ...SCHEDULE_API_CANDIDATES].filter(Boolean);
      return Array.from(new Set(all));
    }

    async function fetchFirstOkJson(urls, init) {
      for (const u of urls) {
        try {
          const resp = await fetch(u, init);
          if (!resp.ok) continue;
          return { url: u, data: await resp.json() };
        } catch {
          // try next
        }
      }
      return null;
    }

    function deriveLiveApiFromScheduleApi(scheduleApiUrl) {
      const raw = (scheduleApiUrl || '').toString().trim();
      if (!raw) return null;

      // Relative worker route.
      if (raw === '/api/schedule') return '/api/schedule/live';

      // FastHosts API uses schedule.php; live check is provided via schedule_live.php.
      if (raw.endsWith('/api/schedule.php')) {
        return raw.replace(/\/api\/schedule\.php$/, '/api/schedule_live.php');
      }

      // Absolute/other variants.
      try {
        const u = new URL(raw);
        if (u.pathname === '/api/schedule') {
          u.pathname = '/api/schedule/live';
          u.search = '';
          u.hash = '';
          return u.toString();
        }
        if (u.pathname.endsWith('/api/schedule.php')) {
          u.pathname = u.pathname.replace(/\/api\/schedule\.php$/, '/api/schedule_live.php');
          u.search = '';
          u.hash = '';
          return u.toString();
        }
      } catch {
        // ignore
      }

      return null;
    }

    function getLiveApiCandidates() {
      const candidates = [];
      // Default worker route.
      candidates.push('/api/schedule/live');

      // Prefer the live endpoint that matches whichever schedule API succeeded.
      const derivedFromLast = deriveLiveApiFromScheduleApi(lastScheduleApiUrl);
      if (derivedFromLast) candidates.push(derivedFromLast);

      // Also try deriving from all schedule candidates.
      for (const s of getScheduleApiCandidates()) {
        const derived = deriveLiveApiFromScheduleApi(s);
        if (derived) candidates.push(derived);
      }

      // De-dupe.
      return Array.from(new Set(candidates));
    }

    function renderWeeklySchedule(items) {
      const container = document.getElementById('weekly-schedule');
      if (!container) return;

      // Sort items by date (expects item.dateKey in 'M-D' format)
      items = items.slice().sort((a, b) => {
        function parseDateKey(key) {
          if (!key) return { m: 0, d: 0 };
          const parts = String(key).split('-');
          return { m: parseInt(parts[0], 10) || 0, d: parseInt(parts[1], 10) || 0 };
        }
        const ad = parseDateKey(a.dateKey);
        const bd = parseDateKey(b.dateKey);
        if (ad.m !== bd.m) return ad.m - bd.m;
        return ad.d - bd.d;
      });

      container.innerHTML = '';

      items.forEach((item) => {
        const card = document.createElement('div');
        card.classList.add('day-card');

        const status = (item && item.status ? String(item.status) : '').toLowerCase();
        const hasStream = status === 'scheduled' || status === 'completed' || status === 'cancelled' || status === 'delayed';
        if (hasStream) card.classList.add('has-stream');
        if (status === 'live') card.classList.add('live');
        if (status === 'completed') card.classList.add('completed');
        if (status === 'cancelled') card.classList.add('cancelled');
        if (status === 'delayed') card.classList.add('delayed');

        const pill = document.createElement('div');
        pill.className = 'status-pill';
        if (status === 'live') {
          pill.textContent = 'LIVE';
          pill.classList.add('live');
        } else if (status === 'completed') {
          pill.textContent = 'COMPLETED';
          pill.classList.add('completed');
        } else if (status === 'cancelled') {
          pill.textContent = 'CANCELLED';
          pill.classList.add('cancelled');
        } else if (status === 'delayed') {
          pill.textContent = 'DELAYED';
          pill.classList.add('delayed');
        } else if (status === 'scheduled') {
          pill.textContent = 'SCHEDULED';
          pill.classList.add('scheduled');
        } else {
          pill.textContent = '';
        }
        if (pill.textContent) card.appendChild(pill);

        if (item && item.dateKey) card.setAttribute('data-date', String(item.dateKey));

        const dayNameEl = document.createElement('div');
        dayNameEl.className = 'day-name';
        dayNameEl.textContent = item && item.dayName ? String(item.dayName) : '-';

        const dateEl = document.createElement('div');
        dateEl.className = 'day-date';
        dateEl.setAttribute('style', 'font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;');
        dateEl.textContent = item && item.dateText ? String(item.dateText) : '';

        const gameLogoEl = document.createElement('div');
        gameLogoEl.className = 'game-logo';
        gameLogoEl.textContent = item && item.gameLogo ? String(item.gameLogo) : '-';

        const streamTimeEl = document.createElement('div');
        streamTimeEl.className = 'stream-time';
        const zuluTime = item && item.zuluTime ? String(item.zuluTime) : '';
        if (zuluTime) streamTimeEl.setAttribute('data-zulu-time', zuluTime);
        streamTimeEl.textContent = item && item.timeText ? String(item.timeText) : (zuluTime || '');

        const streamTitleEl = document.createElement('div');
        streamTitleEl.className = 'stream-title';
        streamTitleEl.textContent = item && item.streamTitle ? String(item.streamTitle) : '-';

        card.appendChild(dayNameEl);
        card.appendChild(dateEl);
        card.appendChild(gameLogoEl);
        card.appendChild(streamTimeEl);
        card.appendChild(streamTitleEl);

        if (status === 'completed' && item && item.vodUrl) {
          const vodLink = document.createElement('a');
          vodLink.href = String(item.vodUrl);
          vodLink.target = '_blank';
          vodLink.rel = 'noopener noreferrer';
          vodLink.setAttribute('style', 'font-size: 0.8rem; color: #66BB6A; margin-top: 0.5rem; font-weight: 600; text-decoration: none; display: block; cursor: pointer; transition: color 0.2s;');
          vodLink.textContent = '‚úì Completed - Watch VOD';
          card.appendChild(vodLink);
        }

        if (status === 'cancelled') {
          const cancelledEl = document.createElement('div');
          cancelledEl.setAttribute('style', 'font-size: 0.8rem; color: #ff6666; margin-top: 0.5rem; font-weight: 600;');
          cancelledEl.textContent = '‚úñÔ∏è Cancelled';
          card.appendChild(cancelledEl);
        }

        if (status === 'delayed') {
          const delayedEl = document.createElement('div');
          delayedEl.setAttribute('style', 'font-size: 0.8rem; color: #FFB74D; margin-top: 0.5rem; font-weight: 700;');
          delayedEl.textContent = '‚è∞ Delayed';
          card.appendChild(delayedEl);
        }

        container.appendChild(card);
      });
    }

    function highlightToday() {
      const today = new Date();
      const month = today.getMonth() + 1;
      const date = today.getDate();
      const dateString = `${month}-${date}`;

      const dayCards = document.querySelectorAll('[data-date]');
      dayCards.forEach(card => {
        if (card.getAttribute('data-date') === dateString) {
          const dateDiv = card.querySelector('.day-date') || card.querySelector('div[style*="font-size: 0.8rem"]');
          if (dateDiv && !dateDiv.textContent.includes('(Today)')) {
            dateDiv.textContent += ' (Today)';
          }
        }
      });
    }

    function ensureStatusPill(card) {
      let pill = card.querySelector('.status-pill');
      if (pill) return pill;
      pill = document.createElement('div');
      pill.className = 'status-pill';
      card.insertBefore(pill, card.firstChild);
      return pill;
    }

    function applyPillForCard(card, forcedText) {
      const pill = ensureStatusPill(card);

      if (forcedText === 'LIVE') {
        pill.textContent = 'LIVE';
        pill.className = 'status-pill live';
        return;
      }

      if (card.classList.contains('completed')) {
        pill.textContent = 'COMPLETED';
        pill.className = 'status-pill completed';
        return;
      }

      if (card.classList.contains('cancelled')) {
        pill.textContent = 'CANCELLED';
        pill.className = 'status-pill cancelled';
        return;
      }

      if (card.classList.contains('delayed')) {
        pill.textContent = 'DELAYED';
        pill.className = 'status-pill delayed';
        return;
      }

      if (card.classList.contains('has-stream')) {
        pill.textContent = 'SCHEDULED';
        pill.className = 'status-pill scheduled';
        return;
      }

      pill.textContent = '';
      pill.className = 'status-pill';
    }

    let lastLiveCheckAt = 0;
    let lastLiveValue = null;
    async function getIsActuallyLive() {
      const now = Date.now();
      // Cache for ~30s to avoid hammering.
      if (now - lastLiveCheckAt < 30000 && lastLiveValue !== null) return lastLiveValue;

      try {
        const candidates = getLiveApiCandidates();
        const cacheBust = `${Date.now()}_${Math.random().toString(16).slice(2)}`;

        for (const u of candidates) {
          try {
            const url = (u && u.includes('?')) ? `${u}&t=${encodeURIComponent(cacheBust)}` : `${u}?t=${encodeURIComponent(cacheBust)}`;
            const resp = await fetch(url, {
              cache: 'no-store',
            });
            if (!resp.ok) continue;

            const json = await resp.json();
            if (!json || json.ok !== true || typeof json.live !== 'boolean') continue;

            lastLiveCheckAt = now;
            lastLiveValue = json.live;
            return json.live;
          } catch {
            // try next
          }
        }

        return null;
      } catch {
        return null;
      }
    }

    let liveStartDateMemory = null;
    function safeLsGet(key) {
      try {
        return localStorage.getItem(key);
      } catch {
        return null;
      }
    }
    function safeLsSet(key, value) {
      try {
        localStorage.setItem(key, value);
        return true;
      } catch {
        return false;
      }
    }
    function safeLsRemove(key) {
      try {
        localStorage.removeItem(key);
        return true;
      } catch {
        return false;
      }
    }

    function parseZuluMinutes(zuluTimeStr) {
      if (!zuluTimeStr) return null;
      const timeMatch = zuluTimeStr.match(/(\d{1,2}):(\d{2})(?:\s(AM|PM))?\s+Zulu/i);
      if (!timeMatch) return null;

      let streamHours = parseInt(timeMatch[1], 10);
      const streamMinutes = parseInt(timeMatch[2], 10);
      const period = timeMatch[3];
      if (period) {
        if (period.toUpperCase() === 'PM' && streamHours !== 12) streamHours += 12;
        else if (period.toUpperCase() === 'AM' && streamHours === 12) streamHours = 0;
      }
      return streamHours * 60 + streamMinutes;
    }

    function getDateKeyFromDate(dateObj) {
      if (!(dateObj instanceof Date)) return '';
      return `${dateObj.getMonth() + 1}-${dateObj.getDate()}`;
    }

    function inferLiveStartDateFromCards(dayCards, todayDateKey, currentUTCTime) {
      if (!dayCards || dayCards.length === 0) return null;

      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayDateKey = getDateKeyFromDate(yesterday);

      let todayCard = null;
      let yesterdayCard = null;

      dayCards.forEach((card) => {
        const key = card.getAttribute('data-date');
        if (key === todayDateKey) todayCard = card;
        if (key === yesterdayDateKey) yesterdayCard = card;
      });

      const candidates = [];

      function pushCandidate(card, dayOffsetMinutes) {
        if (!card) return;
        if (card.classList.contains('cancelled') || card.classList.contains('completed')) return;

        const streamTimeEl = card.querySelector('.stream-time');
        if (!streamTimeEl) return;

        const streamUTCTime = parseZuluMinutes(streamTimeEl.getAttribute('data-zulu-time'));
        if (streamUTCTime === null) return;

        const elapsed = currentUTCTime + dayOffsetMinutes - streamUTCTime;
        if (elapsed >= 0) {
          candidates.push({
            dateKey: card.getAttribute('data-date'),
            elapsed,
          });
        }
      }

      pushCandidate(todayCard, 0);
      pushCandidate(yesterdayCard, 24 * 60);

      if (candidates.length === 0) return null;

      candidates.sort((a, b) => a.elapsed - b.elapsed);
      return candidates[0].dateKey || null;
    }

    function isLiveStartDateStale(liveStartDate, dayCards, todayDateKey, currentUTCTime) {
      if (!liveStartDate) return true;

      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayDateKey = getDateKeyFromDate(yesterday);

      if (liveStartDate !== todayDateKey && liveStartDate !== yesterdayDateKey) {
        return true;
      }

      const card = dayCards.find(c => c.getAttribute('data-date') === liveStartDate);
      if (!card) return true;
      if (card.classList.contains('cancelled') || card.classList.contains('completed')) return true;

      const streamTimeEl = card.querySelector('.stream-time');
      if (!streamTimeEl) return true;

      const streamUTCTime = parseZuluMinutes(streamTimeEl.getAttribute('data-zulu-time'));
      if (streamUTCTime === null) return false;

      const dayOffsetMinutes = (liveStartDate === yesterdayDateKey) ? (24 * 60) : 0;
      const elapsed = currentUTCTime + dayOffsetMinutes - streamUTCTime;

      // If this card's scheduled start is still in the future or implausibly old,
      // treat stored value as stale and re-infer.
      if (elapsed < 0) return true;
      if (elapsed > 20 * 60) return true;

      return false;
    }

    async function updateLiveStatus() {
      const now = new Date();
      const currentUTCHours = now.getUTCHours();
      const currentUTCMinutes = now.getUTCMinutes();
      const currentUTCTime = currentUTCHours * 60 + currentUTCMinutes;

      const today = new Date();
      const month = today.getMonth() + 1;
      const date = today.getDate();
      const dateString = `${month}-${date}`;

      const isActuallyLive = await getIsActuallyLive();
      const dayCards = Array.from(document.querySelectorAll('.day-card'));

      // Track the day the stream started
      let liveStartDate = safeLsGet('fwj_live_start_date') || liveStartDateMemory;

      if (isActuallyLive === true) {
        if (liveStartDate && isLiveStartDateStale(liveStartDate, dayCards, dateString, currentUTCTime)) {
          liveStartDate = null;
          safeLsRemove('fwj_live_start_date');
          liveStartDateMemory = null;
        }

        // Only set if not already set; infer the best matching card first
        // so an overnight stream does not jump to the new day at midnight.
        if (!liveStartDate) {
          liveStartDate = inferLiveStartDateFromCards(dayCards, dateString, currentUTCTime) || dateString;
          safeLsSet('fwj_live_start_date', liveStartDate);
          liveStartDateMemory = liveStartDate;
        }
        // If already set, keep the original value
      } else if (isActuallyLive === false) {
        // If stream ended, clear
        liveStartDate = null;
        liveStartDateMemory = null;
        safeLsRemove('fwj_live_start_date');
      }

      dayCards.forEach(card => {
        const streamTimeEl = card.querySelector('.stream-time');
        if (!streamTimeEl) return;

        const cardDate = card.getAttribute('data-date');
        const isLiveDay = liveStartDate && cardDate === liveStartDate;
        const isToday = cardDate === dateString;
        const isBlockedByStatus = card.classList.contains('cancelled') || card.classList.contains('completed');

        // Show LIVE badge only on the original live day while stream is live.
        if (isActuallyLive === true && isLiveDay && !isBlockedByStatus) {
          card.classList.add('live');
          card.style.cursor = 'pointer';
          applyPillForCard(card, 'LIVE');
        } else {
          card.classList.remove('live');
          card.style.cursor = 'default';

          const zuluTimeStr = streamTimeEl.getAttribute('data-zulu-time');
          const streamUTCTime = zuluTimeStr ? parseZuluMinutes(zuluTimeStr) : null;
          const hasStarted = streamUTCTime !== null && currentUTCTime >= streamUTCTime;

          // If the stream has started and Twitch is offline, treat it as completed.
          // This makes LIVE -> COMPLETED when you end stream, without needing manual edits.
          if (isToday && !isBlockedByStatus && hasStarted && isActuallyLive === false) {
            card.classList.add('completed');
            card.classList.remove('cancelled');
            card.classList.remove('delayed');
          }

          applyPillForCard(card);
        }
      });
    }

    function addLiveCardClickHandler() {
      const dayCards = document.querySelectorAll('.day-card');
      dayCards.forEach(card => {
        if (card.dataset.liveClickBound === '1') return;
        card.dataset.liveClickBound = '1';
        card.addEventListener('click', function() {
          if (this.classList.contains('live')) {
            window.open('https://www.twitch.tv/Flyingwithjoel', '_blank');
          }
        });
      });
    }

    async function run() {
      const container = document.getElementById('weekly-schedule');
      const note = document.getElementById('schedule-note');

      try {
        const result = await fetchFirstOkJson(getScheduleApiCandidates(), { cache: 'no-store' });
        lastScheduleApiUrl = result ? result.url : null;
        const items = result && result.data;

        if (!Array.isArray(items) || items.length === 0) {
          if (note) note.textContent = 'Using fallback schedule (API unavailable).';
        } else {
          renderWeeklySchedule(items);
          if (note) note.textContent = result ? `Loaded from ${result.url}` : '';
        }

        highlightToday();
        await updateLiveStatus();
        addLiveCardClickHandler();
      } catch {
        if (note) note.textContent = 'Could not load schedule (using fallback).';
        highlightToday();
        await updateLiveStatus();
        addLiveCardClickHandler();
      } finally {
        if (container) container.classList.remove('is-hydrating');
      }
    }

    window.addEventListener('load', run);
    window.addEventListener('load', highlightToday);
    window.addEventListener('load', () => updateLiveStatus().catch(() => {}));
    setInterval(() => updateLiveStatus().catch(() => {}), 60000);
    window.addEventListener('load', function() {
      addLiveCardClickHandler();
      setInterval(addLiveCardClickHandler, 60000);
    });

    window.addEventListener('load', function() {
      const sel = document.getElementById('mobile-nav');
      if (!sel) return;
      sel.addEventListener('change', function() {
        const v = this.value;
        if (v) window.location.href = v;
      });
    });
  </script>
</body>
</html>
